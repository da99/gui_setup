#!/usr/bin/env bash
#
#
set -u -e -o pipefail

action=$1
temp="$(dirname $(dirname $(realpath $0)))/tmp"
THIS_DIR="$(dirname "$(dirname $0)")"
THIS_TMP="${THIS_DIR}/tmp"
DB_FILE="${THIS_TMP}/db.desktop.db"
TMP_DB_FILE="/tmp/gui_setup.db.desktop.db"
shift

case $action in
  help|--help)
    bash_setup print_help $0
    ;;

  "desktop_entries")
    # === desktop_entries  # Returns list of .desktop entries
    find  \
      /home/da/.local/share/applications \
      /usr/share/applications/           \
      -ignore_readdir_race -maxdepth 1   \
      -type f                            \
      -iname "*.desktop" | sort
    ;;

  "desktop_entry_to_insert")
    db="$1"
    shift
    path="$1"

    get () {
      # === Example input:
      #   Exec=/path/cmd --dom=romere
      #   Comment=some | title | goes here
      raw="$(grep "${1}=" "$path" | cut -d'=' -f2- | head -n 1)"
      raw="${raw//\'/}"
      raw="${raw//\\t/ }"

      echo -e "$raw"
    }

    id="$(basename $path .desktop)"
    icon_name="$(get "Icon")"
    icon_path="$($0 app_name_to_icon "${icon_name}" || :)"
    try_exec="$(get "TryExec")"
    exec="$(get "Exec" | sed 's/%.//' )"
    terminal="$(get "Terminal")"
    if [[ -z "$terminal" || "$terminal" == "false" ]]; then
      terminal="0"
    else
      terminal="1"
    fi

    comment="$(get "Comment")"

    echo "insert into $db (  \
      id, path, icon_name,   \
      icon_path, try_exec, exec, \
      terminal, comment      \
    ) values (               \
      '$id','$path','$icon_name', \
      '$icon_path','$try_exec','$exec', \
      '$terminal', '$comment' \
    );"
    ;;

  "activate_or_launch")
    # === activate_or_launch id # activates or launches window

    name="$1"
    shift
    case $name in
      gnome-terminal)
        name="gnome-terminal-server"
        ;;
    esac

    win_id="$($0 normal_window_info |  grep --extended-regexp -i '^[^[:space:]]+[[:space:]]'$name'[[:space:]]'  | cut -f1 || :)"
    if [[ -n "$win_id" ]]; then
      wmctrl -ia "$win_id"
    else
      cmd="$(sqlite3 -separator $'\t' "$DB_FILE" "SELECT exec FROM desktops WHERE id = '$name' LIMIT 1;")"
      if [[ -z "$cmd" ]]; then
        echo "== Not found: $name" 1>&2
        exit 1
      fi
      nohup $cmd &>/dev/null &
    fi
    ;;

  "cache_the_machine")
    # === cache_the_machine  # Set up a DB for (.desktop, icon, etc.) lookups.
    if [[ ! -f "$DB_FILE" ]]; then
      rm -f "$TMP_DB_FILE"
      sqlite3 $TMP_DB_FILE "create table desktops ( \
        id TEXT    PRIMARY KEY,                 \
        path       TEXT,                        \
        icon_name  TEXT,                        \
        icon_path  TEXT,                        \
        try_exec   TEXT,                        \
        exec       TEXT,                        \
        terminal   INT DEFAULT 0,               \
        comment    TEXT                         \
      );"

      while read -r FILE; do
        case "$(basename "$FILE" .desktop)" in
          nemo-autorun-software)
            continue
            ;;
          nemo-autostart)
            continue
            ;;
          *)
            echo -n "=== $FILE: "
            sql_cmd="$($0 desktop_entry_to_insert desktops $FILE)"
            { sqlite3 "$TMP_DB_FILE" "$sql_cmd"  2>&1 && echo "inserted"; } || \
              echo "exit $? on $FILE"
            ;;
        esac
      done < <($0 desktop_entries)

      mv -i "$TMP_DB_FILE" "$DB_FILE"
    fi
    ;;

  "select")
    # === select partial_or_full_id # returns TAB-delimited cols, rows
    sqlite3 -separator $'\t' "$DB_FILE" "SELECT id, icon_path, exec, comment FROM desktops WHERE id LIKE '$1%' LIMIT 10;"
    ;;

  "normal_window_info")
    # === normal_window_info # Returns a TAB-delimited list: winid exec_name, pid, title
    info="$(wmctrl -lp | tr -s ' ')"
    win_ids="$(echo -e "$info" | cut -d' ' -f1)"
    types="$(echo -e "$win_ids" | xargs -I ID xprop -id ID _NET_WM_WINDOW_TYPE  | cut -d'=' -f2- | tr -d ' ')"
    pids="$(echo -e "$info" | cut -d' ' -f3)"
    titles="$(echo -e "$info" | cut -d' ' -f5-)"

    full="$(paste <(echo -e "$types") <(echo -e "$win_ids") <(echo -e "$pids") <(echo -e "$titles"))"

    # We first HAVE TO filter out non-normal windows, THEN get the PID/COMM info.
    # This is because sometimes the pid of window is listed as "0". I don't know why.
    #  A pid of "0" will lead "ps" to give us an out-of-range error.
    normal="$(echo -e "$full" | grep _NET_WM_WINDOW_TYPE_NORMAL | cut -f2-)"
    comms="$(echo -e "$normal" | cut -f2 | xargs -I PID ps -o args= -p PID | cut -d' ' -f1 | xargs -I NAME basename NAME  )"

    # procs=""
    # while read -r PID; do
      # temp="$(pstree -An $PID | head -n 10 | tr -d "\n" | tr -s ' ')"
      # if [[ -z "$procs" ]]; then
        # procs="$temp"
      # else
        # procs="${procs}\n${temp}"
      # fi
    # done < <(echo -e "$raw" | tr -s ' ' | cut -d' ' -f3)

    paste <(echo -e "$normal" | cut -f1) <(echo -e "$comms") <(echo -e "$normal" | cut  -f2-)
    ;;

  "watch")
    # === watch
    orig_dir="/apps/gui_setup/tmp"
    mkdir -p $orig_dir
    dir="$(mktemp -d)/gui_setup"
    cp -a $orig_dir/. $dir/

    echo -n "$dir" > "$orig_dir/temp_dir"

    files="$(find                         \
      /apps/*/bin/                       \
      /progs/bin/                        \
      /progs/*/bin                       \
      -ignore_readdir_race -maxdepth 1   \
      -type f)"
    file_list="$dir/files"
    echo -e "$files"    > $file_list

    desktops="$($0 desktop_entries)"
    desktop_list="$dir/desktops"
    echo -e "$desktops" > $desktop_list

    echo "=== Caching icon files..."
    while read -r LINE
    do
      cache="$dir/$(basename $LINE .desktop).png"
      if [[ ! -f "$cache" ]]; then
        file="$($0 desktop_to_icon 24 $LINE)"
        if [[ -z "$file" ]]; then
          echo "=== Skipping $LINE (no icon file)"
        else
          echo "=== copying $file -> $cache"
          cp "$file" "$cache"
        fi
      fi
    done < <(echo -e "$desktops")

    while true; do
      echo "=== Sleeping. On wake: cache window icons..."
      sleep 1
      while read -r id; do
        $0 window_id_to_icon $id
      done < <( wmctrl -l | grep --extended-regexp "^[0-9a-z]+  [0-9]" | cut -d' ' -f1 )
    done

    echo "=== copying TEMP/RAM dir to $orig_dir"
    cp -a $dir/. $orig_dir/
    ;;

  "app_name_to_icon")
    name="$1"
    cd "${THIS_TMP}"
    if [[ ! -d "${THIS_TMP}/xdg-bash-functions" ]]; then
      git clone "https://github.com/martynets/xdg-bash-functions" 1>/dev/null
    fi
    cd "xdg-bash-functions"
    set +u +e +o pipefail
    source ./icon-functions
    icon_functions_init
    find_apps_icon $name && echo "$ICON"
    ;;

  "desktop_to_icon")
    size="$1"
    file="$2"
    raw_icon="$(sed -n 's/.*Icon=\(.*\)\n*/\1/p' $file)"
    icon="${raw_icon//.png/}"
    if [[ -n "$icon" ]]; then
      $0 freedesktop_icon $size $icon
    fi
    ;;

  "freedesktop_icon")
    size="$1"; shift
    name="$1"; shift

    theme="$(sed -n 's/.*gtk-icon-theme-name="\(.\+\)".*/\1/p' $HOME/.gtkrc-2.0 || :)"
    default_theme="$(gsettings get org.gnome.desktop.interface icon-theme || :)"
    default_theme="${default_theme//\'/}"

    dirs="
      $HOME/.local/share/icons/        \
      /usr/share/icons/$theme/         \
      /usr/share/icons/$default_theme/ \
      /usr/share/icons/                \
    "
    file="$(find $dirs -type f -wholename "*${size}*${name}.png" | head -n 1)"

    if [[ -z "$file" ]]; then
      file="$(find $dirs -type f -wholename "*/${name}.png" | head -n 1)"
    fi

    echo $file
    ;;

  "window_list")
    # === $ window_list
    # ===   Returns: "id title ..."

    # === Filter out non-visible windows by insure second column
    #     does not start w/minus sign, as in "-1"
    while read -r LINE; do
      icon=$($0 window_id_to_icon $(echo $LINE | cut -d' ' -f1))
      echo $icon $(echo $LINE | cut -d' ' -f1) $(echo $LINE | cut -d' ' -f4-)
    done < <(wmctrl -l | grep --extended-regexp "^[0-9a-z]+  [0-9]")
    ;;

  "window_id_to_icon")
    # === $ window_id_to_icon 0x0343..
    # === $ window_id_to_icon 0x343..
    # === Creates icon (if it doesn't exist) and returns path to icon.
    RAW_ID="$1"
    shift
    tree="$(xwininfo -root -children -tree)"
    id="${RAW_ID/0x0/0x}"
    props="$(echo "$tree" | grep "$id " | head -n 1)"
    bin="$([[ "$props" =~ ':'\ \(\"(.+)\"\ \" ]] && echo ${BASH_REMATCH[1]})"
    icon="/apps/gui_setup/tmp/${bin// /_}.png"
    if [[ ! -f "$icon" ]]; then
      $0 window_icon! $id $icon || echo "=== error in rendering icon: exit status $? -> $icon" 1>&2
    fi
    echo $icon
    ;;

  "window_icon!")
    raw_id="$1"
    shift
    save_as="$1"

    id="${raw_id/0x0/0x}"
    xprop -id $id -notype 32c _NET_WM_ICON  | perl -0777 -pe '@_=/\d+/g;
    printf "P7\nWIDTH %d\nHEIGHT %d\nDEPTH 4\nMAXVAL 255\nTUPLTYPE RGB_ALPHA\nENDHDR\n", splice@_,0,2;
    $_=pack "N*", @_;
    s/(.)(...)/$2$1/gs' | pamrgbatopng > $save_as
    ;;

  "window_title_grep")
    wmctrl -l | grep -i "$@" | tail -1 | cut -f1 -d' '
    ;;

  "move_to")
    # === move_to center    win_id
    # === move_to left_big  win_id
    # === move_to right_big win_id
    # === move_to next
    dir="$1"
    shift

    if [[ -z "$@" ]]; then
      # From: http://superuser.com/questions/382616/detecting-currently-active-window
      raw_win_id="$(xprop -root 32x '\t$0' _NET_ACTIVE_WINDOW | cut -f 2)"
      win_id="${raw_win_id/0x/0x0}"
    else
      win_id="$1"
      shift
    fi

    wxh="$(wmctrl -d | tr -s ' ' | cut -d' ' -f9)"
    screen_w="$(echo "$wxh" | cut -d'x' -f1)"
    screen_h="$(echo "$wxh" | cut -d'x' -f2)"

    pad=10

    small_window_w=700
    small_window_h=500

    med_window_w=$(( $small_window_w / 2 + $small_window_h))
    med_window_h=$small_window_h

    file="$(dirname "$(dirname $0)")/tmp/win_motion"

    list_motions () {
      cat $0 | grep '# ''win_cycle' | tr -d ' ' | cut -d')' -f1
    }

    case "$dir" in
      left_big) # win_cycle
        wmctrl -ir $win_id -e 0,$pad,$pad,$(($screen_w - $small_window_w - $pad )),$(($screen_h - 100))
        ;;
      left_med) # win_cycle
        wmctrl -ir $win_id -e 0,$pad,$pad,$(($screen_w - $(($small_window_w / 2)) - $small_window_w - $pad )),$(($screen_h - 100))
        ;;
      right_med) # win_cycle
        width=$(($screen_w - $(($small_window_w / 2)) - $small_window_w - $pad ))
        x=$(( $screen_w - $pad - $width ))
        wmctrl -ir $win_id -e 0,$x,$pad,$width,$(($screen_h - 100))
        ;;

      center) # win_cycle
        win="$(wmctrl -lG | tr -s ' ' | grep $win_id | head -n 1)"
        if [[ -z "$win" ]]; then
          echo "!!! Window not found: $win_id" 1>&2
          exit 1
        fi
        win_w="$(echo "$win" | cut -d' ' -f5)"
        win_h="$(echo "$win" | cut -d' ' -f6)"
        x=$(( $screen_w / 2 - $(($win_w / 2)) ))
        y=$(( $screen_h / 2 - $(($win_h / 2)) ))
        wmctrl -ia "$win_id"
        wmctrl -ir "$win_id" -e 0,$x,$y,$win_w,$win_h
        ;;

      center_big) # win_cycle
        width=$(($screen_w - $(( $pad * 4)) ))
        height=$(($screen_h - $(( $pad * 8)) ))
        x=$(( $pad + $pad ))
        y=$(( $pad + $pad ))
        wmctrl -ir $win_id -e 0,$x,$y,$width,$height
        ;;

      left_top_med) # win_cycle
        width=$med_window_w
        height=$med_window_h
        x=$(( $screen_w - $width - $pad ))
        y=$pad
        wmctrl -r :ACTIVE: -e 0,$x,$y,$width,$height
        ;;

      left_bottom_med) # win_cycle
        width=$med_window_w
        height=$med_window_h
        x=$(( $screen_w - $width - $pad ))
        y=$(( $pad + $pad + $med_window_h ))
        wmctrl -r :ACTIVE: -e 0,$x,$y,$width,$height
        ;;

      next)
        motions=$(list_motions)
        count=$(echo -e "$motions" | wc -l)
        if [[ ! -f "$file" ]]; then
          echo "0" > "$file"
        fi
        last="$(cat "$file")"
        if [[ "$last" -eq "$count" ]]; then
          last=0
        fi
        next=$(($last + 1))
        echo "$next" > "$file"
        here=$(echo -e "$motions" | tail -n +$next | head -n 1)
        $0 move_to $here $win_id
        ;;

      prev)
        total=$(list_motions | wc -l)
        if [[ -f "$file" ]]; then
          last="$(cat "$file")"
        else
          last="$total"
        fi
        next="$(( $last - 2 ))"
        if [[ "$next" -lt 0 ]]; then
          next="$(($total - 2))"
        fi
        echo $next > "$file"
        $0 move_to next
        ;;

      *)
        echo "!!! Unknown cmd: $dir" 1>&2
        exit 1
        ;;
    esac
    ;;

  "window")
    # === window
    # move window
    window=$temp/window
    if [[ ! -d $temp ]]; then
      mkdir -p $temp
    fi
    touch $window
    last="$(cat $window)"
    case $last in
      "1")
        wmctrl -r :ACTIVE: -e 0,10,10,950,940
        ;;
      "2") # top right big
        wmctrl -r :ACTIVE: -e 0,970,10,950,500
        ;;
      "3") # bottom right big
        wmctrl -r :ACTIVE: -e 0,970,540,950,520
        ;;
      "4") # top right medium
        wmctrl -r :ACTIVE: -e 0,1250,10,660,470
        ;;
      "5") # bottom right medium
        wmctrl -r :ACTIVE: -e 0,1250,510,660,480
        ;;
      *)
        wmctrl -r :ACTIVE: -e 0,10,10,1900,940
        last="0"
        ;;
    esac
    echo $(($last + 1)) > $window
    ;;

  "install")
    set -x
    content="$(sudo cat /etc/sudoers | grep "systemctrl reboot" || echo "")"
    if [[ -z "$content" ]]; then
      echo "In: /etc/sudoers" 2>&1
      echo "da ALL=NOPASSWD: /usr/bin/systemctl poweroff,/usr/bin/systemctl halt,/usr/bin/systemctl reboot" 2>&1
    fi

    # === install
    sudo pacmatic -S                  \
      unzip faenza-icon-theme         \
      plank plank-extras              \
      ttf-droid noto-fonts            \
      noto-fonts-emoji noto           \
      ttf-dejavu                      \
      ttf-liberation                  \
      bluez bluez-libs bluez-utils    \
      bluez-firmware blueman bluez    \
      vlc libav                       \
      xorg-xrdb xorg-xmodmap          \
      pekwm conky xdbinfo volumeicon  \
      netpbm sqlite                   \
      nemo nemo-fileroller nemo-share \
      perl-file-mimeinfo  gmrun       \
      xdotool xorg-xrdb xorg-xdpyinfo

    set -x
    xdg-mime default nemo.desktop inode/directory
    xdg-mime default google-chrome.desktop x-scheme-handler/http
    xdg-mime default google-chrome.desktop x-scheme-handler/https
    xdg-mime default google-chrome.desktop text/html
    xdg-settings set default-web-browser google-chrome.desktop
    ;;

  "wh")
    # === wh  # === get screen w/h dimensions
    xdbyinfo | grep dimensions
    ;;

  *)
    echo "Unknown option: $action" 1>&2
    exit 1
    ;;

esac
